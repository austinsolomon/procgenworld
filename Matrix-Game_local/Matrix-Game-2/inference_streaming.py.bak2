# wrapper that auto-feeds actions + shows progress, while delegating to your original script
import runpy, builtins, time, sys
from pathlib import Path

# --- detect which underlying script to run (prefer your saved original if present) ---
CANDIDATES = [
    Path("inference_streaming_original.py"),
    Path("inference_streaming.py.bak"),
]
underlying = next((p for p in CANDIDATES if p.exists()), None)
if underlying is None:
    print("[error] Neither inference_streaming_original.py nor inference_streaming.py.bak was found.")
    print("        Cannot wrap the original streaming script.")
    sys.exit(1)

# --- choreography (mouse first, keyboard second, per step) ---
# Mouse: I(up), K(down), J(left), L(right), U(no move)
# Keyboard: W(forward), S(back), A(left), D(right), Q(no move)
mouse_seq    =  (["K"] * 15) + (["I"] * 15) + (["L"] * 120) + (["U"] * 60)
keyboard_seq =  (["Q"] * (15 + 15 + 120)) + (["W"] * 60)

total_steps = len(mouse_seq)  # number of streaming iterations (mouse+keyboard pair)
mouse_idx = 0                 # count only on mouse prompts so progress = iterations done
t0 = None

real_input = builtins.input

def fmt_eta(seconds_left: float) -> str:
    if seconds_left < 0: seconds_left = 0
    m, s = divmod(int(seconds_left), 60)
    h, m = divmod(m, 60)
    return f"{h:02d}:{m:02d}:{s:02d}"

def scripted_input(prompt: str = "") -> str:
    global mouse_idx, t0
    pl = prompt.lower()

    # Let the user type the image path once (don't auto-fill)
    if "image path" in pl:
        print("[hint] Paste your image path (e.g. /home/pg1221/Matrix-Game/Matrix-Game-2/demo_images/temeraire.jpg) and press Enter.")
        return real_input(prompt)

    # Start timer on first action prompt
    if t0 is None:
        t0 = time.time()

    # Mouse prompt: step progress + feed next mouse action
    if "mouse action" in pl:
        done = min(mouse_idx, total_steps)
        elapsed = time.time() - t0
        avg = (elapsed / done) if done > 0 else 0.0
        remaining = (total_steps - done) * avg if avg > 0 else 0.0
        pct = int(round(100 * done / total_steps)) if total_steps else 100
        print(f"[progress] {done:>3}/{total_steps}  ({pct:>3}%)  |  elapsed {int(elapsed//60):02d}:{int(elapsed%60):02d}  |  eta {fmt_eta(remaining)}")

        if mouse_idx < total_steps:
            val = mouse_seq[mouse_idx]
            mouse_idx += 1
            return val
        return "U"  # hold still when choreography ends

    # Keyboard prompt: pair with latest mouse step
    if "keyboard action" in pl:
        idx = min(mouse_idx - 1, total_steps - 1)
        if 0 <= idx < len(keyboard_seq):
            return keyboard_seq[idx]
        return "Q"  # no move fallback

    # Any other prompt -> pass through
    return real_input(prompt)

# Patch input globally
builtins.input = scripted_input

# Hand off to the real script with the same CLI args
try:
    runpy.run_path(str(underlying), run_name="__main__")
finally:
    builtins.input = real_input
